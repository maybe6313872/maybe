1.遍历对象有哪些方法
For in
Object.keys(obj) 获取key数组
Object.getOwnPropertyNames(obj) 获取属性数组

2.说一下自己对作用域和作用域链的理解
作用域：作用域就是变量起作用的区域 或者说 js代码 执行时，查找变量的范围.
作用域链：在寻找变量时，先在最近的作用域（花括号）里找，如果找不到，则从上一级作用域（花括号）里找，依次类推，直到找到或者找不到为止。这就是作用域链.

3.前端存储数据方式有哪些
常见的4种前端存储数据的方式是cookie,LocalStorage, sorage,IndexedDB

4.为什么v-if与v-for不能一起使用
在 Vue 中，v-for 和 v-if 是两个常用的指令，但它们不建议同时使用在同一个元素上。这是因为 v-for 的优先级比 v-if 高，这意味着每次 v-for 循环都会执行 v-if，即使条件不满足，也会遍历整个列表，从而导致性能下降。

5.列举几个vue内置指令
 v-text 、 v-html 、 v-show 、 v-if 、 v-else 、 v-else-if 、 v-for 、 v-on 、 v-bind 、 v-model 、 v-slot 、 v-pre 、 v-cloak 、 v-once 、 v-memo 、 v-is

6.深拷贝与浅拷贝的区别
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存（分支）。 Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。
深拷贝重新创建一个对象，与原对象不共享内存
手写递归方法，JSON.parse(JSON.stringify())  lodash库的deepclone

7.v-show算重排吗？为什么？
（1）两者都会导致页面的重绘和重排，但v-show只是改变dom的css，而v-if控制的是添加和删除dom，所以v-if在重绘重排前还进行了添加或删除dom元素的操作。
（2）需要多次切换某个元素的显示或隐藏时使用v-show
（3）某个元素在渲染后就一直存在或隐藏时使用v-if
（4）opacity也可以隐藏元素，但它本身的作用并非用来隐藏元素而是设置元素的透明度，并且opacity为0时，该dom同样占用着空间。文档流不改变

8.vue2与vue3响应式系统揍什么区别
Vue2 使用 Object.defineProperty 实现数据劫持，通过为对象属性的 getter 和 setter 添加依赖追踪和触发更新。
局限性：
无法监听新增/删除属性：
直接通过 obj.newProp = value 添加属性或 delete obj.prop 删除属性无法触发响应式更新，需使用 Vue.set/Vue.delete。
数组监听受限：
直接通过索引修改数组（如 arr[0] = 1）或修改 length 属性不会触发更新，需使用数组变异方法（如 push, splice）。
初始化性能问题：
递归遍历对象所有属性并转换为响应式，大型对象初始化较慢。
Vue3 对象代理 在内存占用方面，Proxy可能更高效，因为Vue2中每个对象属性都需要单独的getter和setter，而Proxy可以代理整个对象，减少了内存的使用。特别是在处理大型数据集时，这种优化会更加明显。Reactive
 通过函数式 API（如 ）替代 Options API，逻辑复用更灵活，代码组织更清晰。
基于 Proxy 的全面劫持监听动态属性：Proxy 可以拦截对象的所有操作（包括属性增删、数组索引修改），无需手动调用 Vue.set。

支持更多数据类型：如 Map、Set、WeakMap 等原生数据结构。

惰性初始化：只有在访问对象属性时才会递归代理子对象，减少初始化开销。

// Vue3 的响应式对象
import { reactive } from 'vue';
const obj = reactive({ count: 0 });
obj.newProp = 1; // 自动触发响应式更新
delete obj.count; // 自动触发更新
独立的响应式模块
Vue3 的响应式系统 (@vue/reactivity) 与框架解耦，可单独使用，便于集成到其他库或非 Vue 项目。
性能优化
更高效的内存管理：Proxy 直接代理整个对象，无需为每个属性创建 getter/setter。
批量异步更新：通过 queueJob 合并多个状态变更的副作用，减少重复渲染。
更灵活的 API 设计
ref 与 reactive：
reactive：代理对象（类似 Vue2 的 data）。
ref：包装基本类型（如 number），通过 .value 访问值，自动解包（模板中无需 .value）。
effect 与依赖追踪：
提供 watchEffect 和 watch，支持更细粒度的副作用控制。

9给定一个数组，有一个元素重复，找出重复元素并返回，时间复杂度O(n)

10、data为什么用函数？
1.vue中组件是用来复用的，为了防止data复用，将其定义为函数。
2.vue组件中的data数据都应该是相互隔离，互不影响的，组件每复用一次，data数据就应该被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响，就需要通过data函数返回一个对象作为组件的状态。
3.当我们将组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，拥有自己的作用域，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。
4.当我们组件的date单纯的写成对象形式，这些实例用的是同一个构造函数，由于JavaScript的特性所导致，所有的组件实例共用了一个data，就会造成一个变了全都会变的结果。

11、http1和http2的区别？
采用二进制格式而非文本格式
完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
使用报头压缩，降低开销
服务器推送

12.vue之间有哪些通讯？
父传子 props
子传父 emit
全局 vueX / Pinia
直接操作$refs $parent   
vue3不能要用defineExpose操作子组件
子调父 通过父组件provide('parentMethod', parentMethod);  然后子组件const parentMethod = inject('parentMethod');
<template>
  <div>
    <p>{{ message }}</p>
  </div>
</template>
 
<script setup>
defineProps({
  message: {
    type: String,
    required: true
  }
});
</script>
